exit
s
@set
s
@set
n
s
elements
s
disp pair
s
disp bucket
s
pair
s
pair
s
key
bucket
s
key.hash % @size
key.hash
key
s
value
key
bucket
s
key.hash % @size
@map
s
@size
@count
s
pair
s
bucket
s
@map
@map[0]
key.hash % @size
key
@map
c
disp key
c
exit
@map
exit
disp new_array
n
@static
c
exit
old_start
@static
exit
@static
exit
@start_idx
@static
exit
@static
exit
exkt
a
a= [1,2,3, nil, 0]
@start_idx
front_full?
c
front_full?
disp @static
exit
front_full?
c
disp @static
exit
c
disp @static
c
disp @static
exit
c
disp @static
exit
c
full?
disp @static
@static
exit
@end_idx
rear
@end_idx
el
c
disp @static
exit
@end_idx
rear
el
c
disp @static
c
@start_idx
@static
front_full?
c
@start_idx
@static
n
front_full?
c
front_full?
exit
front_full?
@static
c
@end_idx
s
disp @start_idx
s
@static
s
@static
n
s
front_full?
@start_idx
exit
@start_idx
@start_idx -= 1
@start_index
front_full?
@static
exit
exti
@end_idx
@static
exit
front_full?
@end_idx
@static
exit
@static.index(1)
@static.length
@end_idx
@static
exit
@static
exit
@count
(Array.new(@static.length) + @static)[16 - 1]
(Array.new(@static.length) + @static)[16]
(Array.new(@static.length) + @static).length
Array.new(@static.length) + @static
@static
@count
n
@static
@count
@start_idx
n
@static
@start_idx
exit
@static.length
@count - 1
@count
c
exit
@count
@static
c
@static
@count
exit
texit
exi
front_full?
exit
el
@start_idx
full?
c
empty?
exit
@static.length
@count
@openings
@static
empty?
exit
@head
s
@head
c
@q[@head]
@q
self.rear
@head
s
value
@head
exit
1 % @size
1 % size
@head + 1
@size
@head
exit
c
@tail
@q
exit
@tail
@q
exit
@q
s
@q
s
@tail
s
is_empty
@q
c
value
c
self.openings
c
disp @q
exit
@q
c
self.openings
c
n
disp value
exit
@q
exit
c
input
exit
input
